



More Instant Messaging Interoperability                       T. Ralston
Internet-Draft                          The Matrix.org Foundation C.I.C.
Intended status: Standards Track                              K. Kohbrok
Expires: 21 April 2024                                         R. Robert
                                                             Phoenix R&D
                                                              M. Hodgson
                                        The Matrix.org Foundation C.I.C.
                                                         19 October 2023


   More Instant Messaging Interoperability (MIMI) using HTTPS and MLS
                   draft-ralston-mimi-protocol-latest

Abstract

   The More Instant Messaging Interoperability (MIMI) working group is
   chartered to use Messaging Layer Security (MLS) [RFC9420] for its
   encryption/security layers.  This document implements the
   architecture described by [I-D.barnes-mimi-arch], detailing the
   components required to achieve MLS-secured messaging
   interoperability.

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at
   https://turt2live.github.io/ietf-mimi-protocol/draft-ralston-mimi-
   protocol.html.  Status information for this document may be found at
   https://datatracker.ietf.org/doc/draft-ralston-mimi-protocol/.

   Discussion of this document takes place on the More Instant Messaging
   Interoperability Working Group mailing list (mailto:mimi@ietf.org),
   which is archived at https://mailarchive.ietf.org/arch/browse/mimi/.
   Subscribe at https://www.ietf.org/mailman/listinfo/mimi/.

   Source for this draft and an issue tracker can be found at
   https://github.com/turt2live/ietf-mimi-protocol.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 21 April 2024.

Copyright Notice

   Copyright (c) 2023 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
   2.  Conventions and Definitions
   3.  Rooms and Events
     3.1.  Event Schema
     3.2.  Authentication
       3.2.1.  Reference Hash
       3.2.2.  Content Hash
       3.2.3.  Signatures
     3.3.  Creation
       3.3.1.  m.room.create
   4.  User Participation and Client Membership
     4.1.  Invites
     4.2.  Joins
     4.3.  Leaves/Kicks
     4.4.  Bans
     4.5.  Knocks
   5.  TODO: Sections
     5.1.  m.room.redaction
     5.2.  m.room.user
     5.3.  Fanout
     5.4.  Operation: Send Event
     5.5.  Operation: Check Event
   6.  TODO: Scenario content
   7.  Security Considerations
   8.  IANA Considerations
   9.  References
     9.1.  Normative References
     9.2.  Informative References
   Acknowledgments
   Authors' Addresses

1.  Introduction

   The More Instant Messaging Interoperability (MIMI) working group is
   responsible for specifying the set of protocols required to achieve
   secure, modern, messaging interoperability using MLS [RFC9420].
   [I-D.barnes-mimi-arch] outlines an overall architecture for
   interoperable communications, and this document implements those
   components using MLS and HTTP for the security and specific transport
   details.

   Each MIMI room uses state events to track user-level participation
   and interaction with the room, and an accompanied MLS group for
   client-level membership and messaging.  The MLS group's membership
   consists of the clients which belong to the participating users in
   the MIMI room.

   MLS describes an abstract concept of a "Delivery Service" (DS) that
   is specifically responsible for ordering handshake messages and more
   generally delivering messages to the intended recipients.
   Collectively, all of the servers in a MIMI room fulfill the Delivery
   Service role, with the hub server performing the ordering of
   handshake messages.  The hub server is additionally responsible for
   tracking details about the room to assist clients in joining,
   validating events and handshake messages, and enforcing the required
   policy against the room and MLS group states.

   Servers communicate with each other using a mutually authenticated
   mode of TLS [RFC5246] over HTTP [RFC9110].  This document does not
   describe a protocol for clients to communicate with a server.
   Instead, clients use provider-specific APIs to accomplish "last mile"
   delivery of events and messages.

2.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

   Terms and definitions are inherited from [I-D.barnes-mimi-arch].

3.  Rooms and Events

   Rooms, described by [I-D.barnes-mimi-arch], contain both state events
   and an associated MLS group for encryption operations.  State events
   are used to frame information and operations which exist outside of
   the MLS group, such as the user participation list, room policy, and
   other metadata.

   Events are sent in context of a room, authenticated against the
   room's policy, and ordered by the hub server.  Each event
   additionally contains an _event type_ to differentiate its payload
   format from other events.  A state event is an event with a _state
   key_. The combination of the event type and state key form a tuple to
   establish _current state_: the most recently sent state events with
   distinct type and state key pairs.

   The hub server MUST persist at least the current room state, and MAY
   discard user participation events for users who are in the leave
   state.  The hub server SHOULD persist all other events for the
   benefit of other servers in the room.

      *TODO*: Check that this history requirement matches agreed
      semantics.

3.1.  Event Schema

   Events are authenticated against their TLS presentation language
   format (Section 3 of [RFC8446]):

 // See the "MIMI Event Types" IANA registry for values.
 // Example: "m.room.create"
 opaque EventType;

 struct {
    // The room where the event is sent to.
    opaque roomId;

    // The event type.
    EventType type;

    // If present, the event is a state event.
    opaque [[stateKey]];

    // Who or what sent this event.
    opaque sender;

    // The origin server's content hash of the event.
    // See the "Content Hashes" section for information.
    uint8 contentHash[32];

    // The origin server's signature over the event.
    // See the "Signatures" section for information.
    opaque signature<V>;

    // The event IDs which authorize this event to be sent in the room,
    // as defined by the policy.
    // See the "[Event] Authentication" section for information.
    opaque authEventIds[];

    // The event ID of the parent event. This will be an empty string if
    // the `type` is `m.room.create`.
    opaque prevEventId;

    // Additional fields may be present as dependent on event type.
 } Event;

   Note an "event ID" is not specified on the object.  The event ID for
   an event is the sigil $ followed by the URL-Safe Unpadded
   Base64-encoded reference hash (Section 3.2.1) of the event.

   The "origin server" of an event is the server implied by the sender
   field.

   Events are immutable once sent, but may be redacted (Section 3.2) to
   remove non-critical information.

3.2.  Authentication

   Events simultaneously carry information which is critical for the
   protocol to operate, and other information which is less essential.
   The less essential information is often user-supplied, and ideally
   can be removed without "breaking" the room.  MIMI supports removing
   non-critical information from events through _redaction_.

   Redaction creates a consistent representation of an event suitable
   for signing.  It is not an approach for "deleting" an event.
   Deletions are instead handled by the content format for application
   messages in MIMI.

   There are two scenarios where a redaction is applied:

   1.  When a mismatched content hash (Section 3.2.2) for an event is
       received.

   2.  When an m.room.redaction (Section 5.1) message event is received,
       targeting an event.

   When applying a redaction, all fields described by Section 3.1 MUST
   NOT be removed.  Individual event types MAY describe additional
   fields to retain.  All other fields MUST be removed.

   Events are authenticated against their redacted form.  If an event
   fails authentication, it is _rejected_. Rejected events are dropped
   and not forwarded any further.  For example, a hub rejecting an event
   would not send it to follower servers.  A follower server rejecting
   an event sent by a hub would not forward it to local clients.

   The redacted event is signed (Section 3.2.3) to verify that the event
   was sent by the referenced originating server.  If the signature
   verification fails, the event is rejected.

   Each event references a set of "auth events" which permit the event
   to be sent.  This field is populated by the hub server upon receipt
   of a partial event to send.  The specific event types required to be
   referenced in this field are described by the room policy, but are
   typically the m.room.create (Section 3.3.1), and m.room.user
   (Section 5.2) state events at a minimum.  If an event is missing a
   required auth event, or contains a reference to an unknown/rejected
   event, the event is rejected.

   If the event's content hash does not match the calculated content
   hash, the event is redacted before being sent any further.  Note that
   if an event is already manually redacted with a redaction event, it
   will in most cases fail a content hash check.

   Individual event types MAY specify additional authentication
   requirements, such as field validation or ordering requirements.

3.2.1.  Reference Hash

   Events are referenced by ID in relation to each other, forming the
   room history and auth chain.  If the event ID was a sender-generated
   value, any server along the send or receive path could "replace" that
   event with another perfectly legal event, both using the same ID.

   By using a calculated value, namely the reference hash, if a server
   does try to replace the event then it would result in a completely
   different event ID.  That event ID becomes impossible to reference as
   it wouldn't be part of the proper room history.

   An event's reference hash is calculated by redacting it, removing the
   signature field if present, then serializing the resulting object.
   The serialized binary is then hashed using SHA256 [RFC6234].

   To further create an event ID, the resulting hash is encoded using
   URL-Safe Unpadded Base64 and prefixed with the $ sigil.

      *TODO*: Reference "URL-Safe Unpadded Base64" specification.

3.2.2.  Content Hash

   An event's content hash prevents servers from modifying details of
   the event not covered by the reference hash itself.  For example, a
   room name state event doesn't have the name itself covered by a
   reference hash because it's redacted, so it's instead covered by the
   content hash, which is in turn covered by the reference hash.  This
   allows the event to later be redacted without affecting the event ID
   of that event.

   To calculate a content hash, the following fields are removed from
   the event first:

   *  contentHash

   *  signature

   *  authEventIds

   *  prevEventId

   authEventIds and prevEventId are removed because they are populated
   by the hub server.  The content hash is to preserve the origin
   server's event, not the hub server's.

   The resulting object is then serialized and hashed using SHA256
   [RFC6234].

   Note that the event is _not_ redacted in the calculation of a content
   hash.  This is to ensure that _all_ origin-provided fields are
   protected by a hash and trigger redaction if a field changed along
   the send path.

   The content hash is additionally covered by the reference hash and
   event signature.

3.2.3.  Signatures

   An event's content hash covers the unredacted contents, and it's
   reference hash covers the redacted event contents (including the
   content hash).  The hashes alone are not authenticated and require an
   additional verification mechanism.  Signatures provide the needed
   authentication mechanism, and are applied by the event's origin
   server.

   Signatures are computed by first redacting the event, then removing
   the signature, authEventIds, and prevEventId fields if present.  The
   resulting object is then serialized and signed using the server's
   key.

      *TODO*: Use mTLS keys?  Source drafts use Ed25519 keys, but then
      we need to distribute keys all over the place.

   Like content hashes (Section 3.2.2), authEventIds and prevEventId are
   removed from the event because they are populated by the hub server.

3.3.  Creation

   Rooms (and therefore MLS groups) are first created within the
   provider, out of scope from MIMI.  When the room is exposed to
   another server over the MIMI protocol, such as with an explicit
   invite to another user, the creating server MUST produce the
   following details:

   *  An m.room.create (Section 3.3.1) state event describing the
      encryption and policy details for the room.

   *  A universally unique room ID (represented by the create event).

   *  An m.room.user (Section 5.2) state event which points to the
      create event as a parent for the create event's sender.

   *  An MLS group with a group ID matching the room ID, and contains a
      device belonging to the create event's sender.

   This is the minimum state required by a MIMI room.  Room creators MAY
   wish to include additional details in the initial state, such as
   configuration of the room's policy, adding the creator's other
   clients to the MLS group state, etc.

3.3.1.  m.room.create

   *Event type*: m.room.create

   *State key*: Zero byte length string.

   *Additional event fields*:

   struct {
      // TODO
   } CreateEvent;

      *TODO*: Include fields for policy information (previously called a
      "policy ID" in ralston-mimi-signaling).  Protect this new field
      from redaction.

      *TODO*: Include fields for encryption information.  Possibly
      ciphersuite and similar so a server can check to ensure it
      supports the MLS dialect?  Protect this new field from redaction.

   *Additional authentication rules*:

   *  The event's prevEventId MUST be a zero byte length string.

   *  The event's authEventIds MUST be empty.

   *  The event MUST be the first event in the room.

4.  User Participation and Client Membership

   In a MIMI room, users are _participants_ with an associated
   _participation state_ whereas clients of those users are _members_ of
   the MLS group.  In most scenarios, the user's participation state is
   updated first or simultaneously with the MLS group membership to
   enforce membership more easily.

   Users will always exist in one of the following participation states:

   enum {
      invite,  // "Invited" state.
      join,    // "Joined" state.
      leave,   // "Left" state (including Kicked).
      ban,     // "Banned" state.
      knock,   // "Knocking" state.
      (65535)
   } ParticipationState;

   These states allow a user to remain logically "joined" to the
   conversation when they have zero MLS-capable clients available.  The
   user will not be able to see messages sent while they had no clients,
   but can perform an external join at any time to get back into the MLS
   group.  A user with zero clients in the MLS group is considered to be
   an _inactive participant_. Users with one or more clients in the MLS
   group are _active participants_.

   All servers with at least one user of theirs in the "joined"
   participation state are considered to be "in" or "participating" in
   the room.  By default, all events sent to a room are distrubuted by
   the hub to participating servers.  This is discussed further in
   Section 5.3.

4.1.  Invites

   An _invite_ is when a user (or more specifically, a user's client) is
   attempting to introduce _all_ of another user's clients to the room
   and MLS group.  This is first done by updating the target user's
   participation state through the hub server for the room.

   Updating the target user's participation state is done using the
   following steps, and is visualized in Figure 1.

   1.  The inviter's server generates an m.room.user (Section 5.2) state
       event to invite the target user.  Typically this begins with a
       client-initiated request to the server using the provider-
       specific API.

   2.  The inviter's server sends (Section 5.4) the m.room.user event to
       the hub server.  If the inviter's server is the hub server, it
       does the steps described in Section 5.4 to complete the event.

   3.  The hub server validates the event to ensure the following:

       *  The target user of the invite MUST NOT already be in the
          banned or joined states.

       *  The sender of the invite MUST already be in the joined state.

   4.  If the event is invalid, it is rejected.  Otherwise, it is
       forwarded by the hub to the target user's server to give it the
       opportunity to reject the invite early in the process.  This is
       described by Section 5.5.

   5.  If the target server rejected the event, the event is rejected by
       the hub as well.  Otherwise, the event is fanned out
       (Section 5.3) to all participating servers, plus the target
       server if not already participating.

   At this stage, the _user_ is now invited but their clients are not
   members of the MLS group.  The invite is delivered to the target's
   clients through relevant provider-specific API where the user can
   then accept or decline the invite.

   If the user declines the invite, they are transitioned to the leave
   state described by Section 4.3.  Accepting is done by joining
   (Section 4.2) the room.

  +---+                            +-----+                         +---+
  | A |                            | Hub |                         | B |
  +---+                            +-----+                         +---+
    |                                 |                              |
    | Create m.room.user invite       |                              |
    |--------------------------       |                              |
    |                         |       |                              |
    |<-------------------------       |                              |
    |                                 |                              |
    | Send event request initiated    |                              |
    |-------------------------------->|                              |
    |                                 |                              |
    |                                 | Validate m.room.user event   |
    |                                 |---------------------------   |
    |                                 |                          |   |
    |                                 |<--------------------------   |
    |                                 |                              |
    |    200 OK to send event request |                              |
    |<--------------------------------|                              |
    |                                 |                              |
    |                                 | Check event request          |
    |                                 |----------------------------->|
    |                                 |                              |
    |                                 |                       200 OK |
    |                                 |<-----------------------------|
    |                                 |                              |
    |           Async fanout of event | Async fanout of event        |
    |<--------------------------------|----------------------------->|
    |                                 |                              |

                       Figure 1: Invite happy path

4.2.  Joins

4.3.  Leaves/Kicks

4.4.  Bans

4.5.  Knocks

   In this state, the sender of a knock is requesting an invite
   (Section 4.1) to the room.  They do not have access to the MLS group.

      *TODO*: Discuss if this participation state is desirable, and
      figure out details for how it works.  It'd likely just be an
      m.room.user state event with no MLS interaction, like invites are.

5.  TODO: Sections

   _These headers exist as placeholder anchors._

      *TODO*: This placeholder section should be removed before first
      publish.

5.1.  m.room.redaction

5.2.  m.room.user

5.3.  Fanout

   _Reference Section 4_.

5.4.  Operation: Send Event

   _Reference "complete fields on event and resume further processing
   before Section 5.3"_.

5.5.  Operation: Check Event

   _Ensure supports policy, encryption, and has consent_.

6.  TODO: Scenario content

      *TODO*: This placeholder section should be removed before first
      publish.

      *TODO*: Incorporate these scenario flows.

   Alice adds Bob:

   1.  Alice creates room.

   2.  Alice signals invite for Bob.

   3.  Hub server (Alice's) contacts Bob's server and sends invite.

   4.  Bob's server checks that it is capable of participating.

   5.  Bob's clients receive invite.

   6.  Later: Bob's client accepts invite by sending a join signaling
       event through the hub to all other participants.

   7.  Bob's client retrieves GroupInfo.

   8.  Bob creates and sends an external commit through the hub.

   Alice adds Bob (alternative):

   1.  Alice creates room.

   2.  Alice discovers all of Bob's clients.

   3.  Alice prepares Welcome messages, attaches them to a signaling
       join event for Bob.

   4.  That package is sent via the hub to Bob's server.

   5.  Bob's server verifies it is capable of participating.

   6.  Bob's server acks the request as OK, informs Bob that they're now
       joined and delivers accompanying Welcome messages.

   7.  Concurrent to the ack, hub fans out the join.

   8.  Bob is now both a participant and a member.

   Alice leaves:

   1.  Alice proposes self-eviction via remove proposals.

   2.  Alice leaves via signaling event.

   3.  Hub requires Alice's proposals to be committed next.

   Alice leaves (alternative):

   1.  Alice leaves via signaling event.

   2.  Hub (or any other member) generates remove proposals for Alice.

   3.  Hub requires those proposals to be committed next.

7.  Security Considerations

      *TODO*: Populate this section.

8.  IANA Considerations

   This document has no IANA actions.

      *TODO*: Populate this section.

9.  References

9.1.  Normative References

   [I-D.barnes-mimi-arch]
              Barnes, R., "An Architecture for More Instant Messaging
              Interoperability (MIMI)", Work in Progress, Internet-
              Draft, draft-barnes-mimi-arch-01, 22 September 2023,
              <https://datatracker.ietf.org/doc/html/draft-barnes-mimi-
              arch-01>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246,
              DOI 10.17487/RFC5246, August 2008,
              <https://www.rfc-editor.org/rfc/rfc5246>.

   [RFC6234]  Eastlake 3rd, D. and T. Hansen, "US Secure Hash Algorithms
              (SHA and SHA-based HMAC and HKDF)", RFC 6234,
              DOI 10.17487/RFC6234, May 2011,
              <https://www.rfc-editor.org/rfc/rfc6234>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

   [RFC9110]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "HTTP Semantics", STD 97, RFC 9110,
              DOI 10.17487/RFC9110, June 2022,
              <https://www.rfc-editor.org/rfc/rfc9110>.

   [RFC9420]  Barnes, R., Beurdouche, B., Robert, R., Millican, J.,
              Omara, E., and K. Cohn-Gordon, "The Messaging Layer
              Security (MLS) Protocol", RFC 9420, DOI 10.17487/RFC9420,
              July 2023, <https://www.rfc-editor.org/rfc/rfc9420>.

9.2.  Informative References

   [I-D.kohbrok-mimi-transport]
              Kohbrok, K. and R. Robert, "MIMI Transport", Work in
              Progress, Internet-Draft, draft-kohbrok-mimi-transport-01,
              21 September 2023, <https://datatracker.ietf.org/doc/html/
              draft-kohbrok-mimi-transport-01>.

   [I-D.ralston-mimi-policy]
              Ralston, T. and M. Hodgson, "MIMI Policy Envelope", Work
              in Progress, Internet-Draft, draft-ralston-mimi-policy-00,
              22 September 2023, <https://datatracker.ietf.org/doc/html/
              draft-ralston-mimi-policy-00>.

   [I-D.ralston-mimi-signaling]
              Ralston, T. and M. Hodgson, "MIMI Signaling Protocol",
              Work in Progress, Internet-Draft, draft-ralston-mimi-
              signaling-00, 22 September 2023,
              <https://datatracker.ietf.org/doc/html/draft-ralston-mimi-
              signaling-00>.

   [I-D.robert-mimi-delivery-service]
              Robert, R. and K. Kohbrok, "MIMI Delivery Service", Work
              in Progress, Internet-Draft, draft-robert-mimi-delivery-
              service-04, 21 September 2023,
              <https://datatracker.ietf.org/doc/html/draft-robert-mimi-
              delivery-service-04>.

   [RFC8446]  Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018,
              <https://www.rfc-editor.org/rfc/rfc8446>.

Acknowledgments

   This document is the consolidation of the following documents:

   *  [I-D.robert-mimi-delivery-service]

   *  [I-D.ralston-mimi-signaling]

   *  [I-D.kohbrok-mimi-transport]

   Aspects of [I-D.ralston-mimi-policy] are additionally taken into
   consideration in this document, but is largely unincorporated and may
   require updates to match this document's specifics.

Authors' Addresses

   Travis Ralston
   The Matrix.org Foundation C.I.C.
   Email: travisr@matrix.org


   Konrad Kohbrok
   Phoenix R&D
   Email: konrad.kohbrok@datashrine.de


   Raphael Robert
   Phoenix R&D
   Email: ietf@raphaelrobert.com


   Matthew Hodgson
   The Matrix.org Foundation C.I.C.
   Email: matthew@matrix.org
